import numpy as np
import matplotlib.pyplot as plt
from matplotlib.colors import Normalize
import pandas as pd
import geopandas as gpd
import cartopy.crs as ccrs
import cartopy.feature as cfeature
from cartopy.feature import NaturalEarthFeature
from cartopy.io import srtm
from shapely.geometry import Point, Polygon, mapping
from shapely.ops import nearest_points
from datetime import datetime

def linestring_to_polygon(fili_shps):
    gdf = gpd.read_file(fili_shps) #LINESTRING
    geom = [x for x in gdf.geometry]
    all_coords = mapping(geom[0])['coordinates']
    lats = [x[1] for x in all_coords]
    lons = [x[0] for x in all_coords]
    polyg = Polygon(zip(lons, lats))
    return gpd.GeoDataFrame(index=[0], crs=gdf.crs, geometry=[polyg])

class BNDCdataSet(gpd.GeoDataFrame):
    """
    Main class representing a dataset from a BNDC consult

    """
    def __init__(self, data=None, geometry=None, table_type=None, date=None, **kwargs):
        # Use GeoPandas GeoDataFrame constructor
        super().__init__(data, geometry=geometry, **kwargs)
        
        self.table_type = table_type 
        self.date = date

    @classmethod
    def from_csv(cls, csv_path, crs='EPSG:25830'):
        # Read CSV file
        df = pd.read_csv(csv_path, sep=';')

        # Convert the DataFrame to a GeoDataFrame with Point geometries
        geometry = [Point(xy) for xy in zip(df['C_X'], df['C_Y'])]
        gdf = gpd.GeoDataFrame(df, geometry=geometry, crs=crs)  # Assuming ETRS89/UTM30 as default

        # Extract type and date information from the CSV file or set default values
        data_type = "Standard"
        data_date = datetime(1980, 1, 1)

        # Create an instance of BNDCdataSet
        return cls(data=gdf, table_type=data_type, date=data_date)
    
    @classmethod
    def from_txt(cls, txt_path, crs='EPSG:25830'):
        # Read TXT file
        df = pd.read_csv(txt_path, sep=';') # TODO: Rewrite to get input from txt file generated by ConsultasBNDC

        # Convert the DataFrame to a GeoDataFrame with Point geometries
        geometry = [Point(xy) for xy in zip(df['C_X'], df['C_Y'])]
        gdf = gpd.GeoDataFrame(df, geometry=geometry, crs=crs)  # Assuming ETRS89/UTM30 as default

        # Extract type and date information from the CSV file or set default values
        data_type = "Standard"
        data_date = datetime(1980, 1, 1)

        # Create an instance of BNDCdataSet
        return cls(data=gdf, table_type=data_type, date=data_date)
    
    def compute_distance_to_sea(self, coast_shapefile):
        """
        Calculates distance to sea using ccrs.NaturalEarthFeature for each point
        and adds a new column with this info to the dataset
        """
        #coastline_geo = gpd.read_file(gpd.datasets.get_path('naturalearth_lowres'))
        #coastline_geo = coastline_geo[coastline_geo['name'] == 'Spain'].dissolve(by='name')
        coastline_geo = linestring_to_polygon(coast_shapefile)
        coastline_geo = coastline_geo.to_crs(self.crs)

        # Calculate the distance to the coast for each point
        self['distance_to_sea'] = self.apply(lambda row: row['geometry'].distance(coastline_geo['geometry']), axis=1)


        print(coastline_geo)
        print(self)
        coastline_geo.plot()
        plt.show()

        
    def plot_data_points(self, color_by='ALTITUD', cmap='viridis', markersize=10, figsize=(10, 8)):
        """
        Plot the data points on a map.

        Parameters:
        - color_by (str): Variable to use for coloring the points.
        - cmap (str): Colormap to use for coloring.
        - markersize (int): Size of the markers.
        - figsize (tuple): Figure size.

        Returns:
        - matplotlib.axes._subplots.AxesSubplot: The plot.
        """
        # Check if 'type' variable exists
        if color_by not in self.columns:
            raise ValueError(f"Variable '{color_by}' not found in the dataset.")

        # Create a map using Cartopy
        fig, ax = plt.subplots(figsize=figsize, subplot_kw={'projection': ccrs.PlateCarree()})
        ax.coastlines(resolution='10m', color='black', linewidth=1)


        # Add boundaries of autonomous communities
        provinces_boundaries = NaturalEarthFeature(
            category='cultural',
            name='admin_1_states_provinces_lines',
            scale='10m',
            facecolor='none',
            edgecolor='black'
        )
        ax.add_feature(provinces_boundaries, linestyle=':', linewidth=1)

        # Add land
        ax.add_feature(cfeature.LAND, color='lightgray')

        # Assuming the original data is in ETRS89/UTM30, set the transform accordingly
        data_crs = ccrs.UTM(30)
        ax.set_extent([self.total_bounds[0], self.total_bounds[2], self.total_bounds[1], self.total_bounds[3]], crs=data_crs)

        # Plot data points
        scatter = ax.scatter(
            self.geometry.x,
            self.geometry.y,
            c=self[color_by],
            cmap=cmap,
            s=markersize,
            transform=data_crs,  # Transform for the data points
            edgecolor='k',  # Black border for markers
            norm=Normalize()  # Normalize the color scale
        )

        # Add colorbar
        cbar = plt.colorbar(scatter, ax=ax, label=color_by)

        # Set plot title
        plt.title("BNDC Data Points Map")

        # Set aspect ratio
        ax.set_aspect('equal', adjustable='box')

        return ax
    
    def __str__(self):
        return super().__str__()

if __name__ == "__main__":
    # Example Usage:
    csv_file_path = "./AppInput/Pcp072023.csv"
    coast_shapefile ='./tools/assets/ne_10m_coastline/ne_10m_coastline.shp'
    bndc_dataset = BNDCdataSet.from_csv(csv_file_path)

    # Plotting data points colored by 'type'
    #bndc_dataset.plot_data_points(color_by='ALTITUD', cmap='viridis', markersize=10, figsize=(10, 8))

    # Show the plot
    #plt.show()

    bndc_dataset.compute_distance_to_sea(coast_shapefile=coast_shapefile)
    bndc_dataset.plot_data_points(color_by='distance_to_sea', cmap='viridis', markersize=10, figsize=(10, 8))
    plt.show()